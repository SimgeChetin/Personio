with new_mrr as (
    select
        customers.subscription_id
        , min(invoice.invoice_created_month) as first_invoice_created_month
    from {{ ref('fact_invoices') }} as invoice
    inner join {{ ref('dim_customers') }} as customers
        on invoice.customer_id = customers.customer_id
    group by 1
)

, revenue_generated as (
    select
        cust_subs_monthly.customer_id
        , cust_subs_monthly.subscription_id
        , date_trunc('month', dates.date_day) as billing_year_month
        , cust_subs_monthly.billing_year_month as customer_billing_year_month
        , cust_subs_monthly.customer_status
        , cust_subs_monthly.customer_churn_billing_year_month
        , cust_subs_monthly.subs_start_billing_year_month
        , cust_subs_monthly.subs_end_billing_year_month
        , cust_subs_monthly.is_subscription_to_renew
        , cust_subs_monthly.months_left_to_new_subscription
        ----upgrade & downgrade revenue 
        , coalesce(sum(invoice.upgrade_invoice_amount),0) as  upgrade_revenue
        , coalesce(sum(invoice.downgrade_invoice_amount),0) as downgrade_revenue
        ----revenue generated by customer and their subscriptions based on billing
        , coalesce(sum(invoice.total_invoice_charge_amount), 0) as revenue
        , coalesce(sum(invoice.total_invoice_charge_amount_with_discount), 0 ) as revenue_after_discounts
        , coalesce(lag(revenue) over (partition by cust_subs_monthly.customer_id, cust_subs_monthly.subscription_id 
            order by customer_billing_year_month),0) as starting_month_revenue
        , coalesce(lag(revenue_after_discounts) over (partition by cust_subs_monthly.customer_id, cust_subs_monthly.subscription_id  
            order by customer_billing_year_month), 0) as starting_month_revenue_after_discounts
        , coalesce(case when cust_subs_monthly.customer_status = 'churned' then starting_month_revenue end, 0) as churn_lost_revenue
        , coalesce(case when cust_subs_monthly.customer_status = 'churned' then starting_month_revenue_after_discounts end, 0) as churn_lost_revenue_after_discounts
        ----- revenue generated by customer and their subscriptions based on payment, cash revenue
        , coalesce(sum(payments.payment_amount), 0) as revenue_cash
        , coalesce(lag(revenue_cash) over (partition by cust_subs_monthly.customer_id, cust_subs_monthly.subscription_id order by customer_billing_year_month asc ),0) as starting_month_revenue_cash
        , coalesce(case when cust_subs_monthly.customer_status = 'churned' then starting_month_revenue_cash end,0) as churn_lost_revenue_cash
    from {{ ref('dates') }}
    left join
    {{ ref('dim_customers_subscriptions_monthly') }} as cust_subs_monthly
    on date_trunc('month', dates.date_day) = customer_billing_year_month
    left join {{ ref('fact_invoices') }} as invoice
        on cust_subs_monthly.customer_id = invoice.customer_id
            and customer_billing_year_month = invoice.invoice_created_month
    left join {{ ref('fact_payments') }} as payments
        on cust_subs_monthly.subscription_id = payments.subscription_id
            and customer_billing_year_month = payments.payment_year_month
    where billing_year_month <= add_months(date_trunc('month', current_date()), 6)
    group by all
)


select
    revenue_generated.*
    , coalesce(case when new_mrr.first_invoice_created_month = revenue_generated.billing_year_month then revenue_generated.revenue end,0) as new_revenue
    , coalesce(case when new_mrr.first_invoice_created_month = revenue_generated.billing_year_month then revenue_generated.revenue_after_discounts end,0) as new_revenue_after_discounts
    , new_mrr.first_invoice_created_month = revenue_generated.billing_year_month as is_new_subscription
    ---- Gross revenue generated by billing : 
    ---- if the subscription is new --> new_revenue (already includes application purchase)
    ---- if the subscription is not new --> starting_month_revenue + upgrade_revenue
    , case when is_new_subscription then
        new_revenue
        else 
        revenue_generated.starting_month_revenue + revenue_generated.upgrade_revenue
    end as gross_revenue
    ---- Net Revenue generetaed by billing after discounts: 
    ---- if the subscription is new --> new_revenue_after_discounts - downgrade_revenue (customer switching to subscription with lower cost)
    ---- if the subscription is not new --> starting_month_revenue_after_discounts + upgrade_revenue - downgrade_revenue - churn_lost_revenue_after_discounts(if customers has churned)
    , case when is_new_subscription then 
        + new_revenue_after_discounts
        -- in case when a customer switches to another subscription with lower price,
        -- then the switch would be marked as downgrade
        - revenue_generated.downgrade_revenue
        else 
        revenue_generated.starting_month_revenue_after_discounts 
        + revenue_generated.upgrade_revenue 
        - revenue_generated.churn_lost_revenue_after_discounts 
        - revenue_generated.downgrade_revenue
    end as net_revenue
    -- GRR & NRR
    , case when not is_new_subscription and starting_month_revenue_after_discounts > 0 then
        (starting_month_revenue_after_discounts 
         - churn_lost_revenue_after_discounts 
         - downgrade_revenue) 
        / starting_month_revenue_after_discounts
    end as gross_revenue_retention
    , case when not is_new_subscription and starting_month_revenue_after_discounts > 0 then
        (starting_month_revenue_after_discounts 
         + upgrade_revenue 
         - churn_lost_revenue_after_discounts 
         - downgrade_revenue)
        / starting_month_revenue_after_discounts
    end as net_revenue_retention
    , revenue_generated.customer_status = 'churned' as is_customer_churned
    , datediff('month', revenue_generated.billing_year_month, revenue_generated.customer_churn_billing_year_month) as months_left_to_churn
from revenue_generated
left join new_mrr
    on revenue_generated.subscription_id = new_mrr.subscription_id